操作系统是计算机硬件和用户之间的接口，它使得其他程序更加方便有效的运行，并能方便的对计算机硬件和软件资源进行访问
	操作系统的主要设计目标
		有效的使用硬件
		容易的使用资源
	自举
		操作系统负责把其他程序装入内存，但是它自己也是程序，就需要用到自举程序把它先装入内存
		只分配小部分ROM给自举程序，当计算机被加电时，CPU程序计数器被设置为自举程序的第一条指令地址
		这个程序唯一的职责就是把操作系统本身装入RAM
		当装入完成后，CPU中的程序计数器就被设置为RAM中操作系统的第一条指令的地址
演化
	批处理系统
		当时的计算机用穿孔卡带输入数据与程序，用打印机输出结果
		每个程序的运行叫一个作业，这个时代的操作系统只负责计算机所有资源从一个作业转换到另一个作业
	分时系统
		为了更有效使用计算机，多道程序的概念被引入
		它可以将多个作业同时装入内存，并且仅当资源可用时分配给需要使用资源的作业
		多道程序带来了分时的概念，资源可以被不同的资源分享，每个作业可以分到一部分时间使用资源
		因为计算机运行速度很快，所以分时系统对用户来说是隐藏的
		利用分时系统的多道程序极大的改进了计算机的使用效率，但是需要更复杂的操作系统
		它必须可以调度，给不同的程序分配资源并决定哪个程序什么时候使用哪个资源
		进程这个术语随之产生，一个作业是要运行的程序，一个进程则是一个在内存中等待分配资源的程序
	个人系统
		适合PC的操作系统，例如DOS
	并行系统
		在同一系统中安装了多个CPU，每个CPU可以处理一个程序或者一个程序的一部分
		意味着任务可以并行处理，操作系统也比单CPU复杂很多
	分布式系统
		网络的发展扩大了操作系统的内涵，程序可以在一个计算机上运行一部分而在另外一个计算机上运行其他部分
		只要通过网络链接即可，资源是分布式的
		分布式系统结合了以往系统的特点和新的功能，例如安全控制
	实时系统
		实时系统指在特定时间内完成任务的系统，他们被用在实时应用程序内
		在交通控制、病人监控或军事系统中可以见到实时系统的例子
组成部分
	现在的操作系统十分复杂，它必须可以管理系统中不同的资源。
	现代操作系统至少具有以下四种功能
		内存管理、进程管理、设备管理、文件管理
	还有一个部分不归任何部分管理，称为用户界面或命令解释程序
	用户界面
		用户界面就是用来接受用户或进程的输入并向操作系统解释这些请求的程序
		例如WINDOS的图形界面，CMD，UNIX的用户界面被称为命令解释程序（shell）
	内存管理器
		内存分配必须进行管理以避免内存溢出，操作系统按照内存管理可分为两大类，单道程序和多道程序
		单道程序
			单道程序的内存管理早已过时，在单道程序中，大多数内存用来装载单一的程序，小部分装哉操作系统
			在这种配置下，整个程序装入内存运行，运行结束后，程序区域由其他程序替代
			程序如果比内存容量大，程序将无法运行
			当一个程序运行中，其他程序不能运行，当程序使用I/O设备时，由于I/O设备比CPU慢，CPU空闲不能执行其他程序
		多道程序
			在多道程序下，同一时刻装入多个程序执行，CPU轮流为其服务，多种技术可以实现多道程序
			分区调度
				内存被分为几个不定长的分区存储程序，CPU在各个程序间交替服务
				CPU可以通过优先级管理，用于控制分配给每个程序的时间
				在这种技术下，分区的大小必须由内存管理器预先决定，小了程序不能载入，大了会有空闲区
				即使刚开始分好区，随着新程序交换载入会有空闲区
				当空闲区过多时，内存管理器能够紧缩空间删除空闲区创建新区，但这将增加系统开销
			分页调度
				在分页调度下，内存被分为大小相等的若干个部分，称为帧
				程序被分为同样大小的部分，称为页
				并且与系统用于从存储设备中提取信息的块大小相等
				在这种技术下，程序在内存中不必占据连续的内存
				一个需要六个帧的程序可以用两个不连续的三帧的空间
				但是还是需要在运行前载入所有内容，只有四个帧时，需要六个帧的程序不能载入
			请求分页调度
				同一个程序的连续页不用全部载入内存，可以在一帧里一词载入执行
			请求分段调度
				程序将以程序员的角度划分成段，比如主程序和子程序
				它们载入内存中执行，然后被来自同一程序或其他程序的模块代替
			请求分页和分段调度
				结合了两者优点结合了两者的优点，一个段太大可以分成页，内存也可以分成帧
		虚拟内存
			请求分页调度和请求分段调度意味着程序运行时，一部分在内存中，一部分在硬盘上
			需要在硬盘中有和程序同等大小的虚拟内存
			运行时物理内存和虚拟内存中交换数据，让程序认为它有连续可用的内存
	进程管理器
		程序
			程序是由程序员编写的一组稳定的指令，可能也可能不会成为作业
		作业
			从一个程序被选中执行，到运行结束再次变成程序的过程中，该程序被称为作业
			作业可能会或不被执行，每个作业都是程序，但是程序不一定是作业
		进程
			进程是一个运行中的程序，是驻留在内存中运行的作业，只要作业装入内存就是进程
			进程都是作业，作业不一定是进程
		调度器
			作业调度器
				作业调度器将一个作业从保持状态转入就绪状态，或是从运行转入终止状态
				也就是负责从作业中创建和终止一个进程
			进程调度器
				进程调度器把一个进程从一个状态转入另一个状态
				也就是负责管理进程就绪运行和等待的状态
				一些操作系统使用其他调度器使进程之间的转换更加有效
		队列
			会有很多的作业和进程抢夺计算机资源，进程管理器使用队列来管理这些作业和进程
			进程管理在队列中存储作业控制块和进程控制块，这些控制块含有进程和作业的信息
			一个操作系统会有很多个队列，例如作业队列，就绪队列，I/O队列等
			进程管理器可以用多种策略从队列中选择下一个作业或进程，先入先出，最短长度有限等
		进程同步
			只要资源可以被多个进程同时使用，那么它就可能有两种有问题的状态：死锁和饥饿
			死锁
				一个文件在被一个进程使用时，不能被其他进程使用
				如果一个进程需要调用另一个正在被使用的文件才能释放它正在调用的文件
				而那个文件也需要调用这个进程中的文件，就会发生死锁
				死锁发生需要四个必要条件
					互斥：一个资源只能被一个进程占有
					资源占有：一个进程占有一个资源
					抢先：操作系统不能临时对资源进行分配
					循环等待：所有的进程和资源包含在一个循环里
					这四个条件是必要条件，引发死锁一定满足这四个条件，但是这四个条件不一定引发死锁
			饥饿
				假设一个操作系统规定一个进程只有在所需的所有资源都为其占用时才能执行
				那么一个进程可能由于需要的几个文件无法同时凑齐而一直得不到执行
	设备管理器
		负责访问输入输出设备
		设备管理器不停地监视所有的输入输出设备，保证他们能正常运行
		管理器同样需要知道何时设备已经完成一个进程的服务从而能为队列中下一个进程服务
		设备管理器为每一个输入输出设备维护一个队列
		设备管理器还可以控制用于不同设备的不同策略
	文件管理器
		文件管理器控制文件的访问，获取权限的应用程序才可以访问，访问方式也可以不同，比如只读，只写
、		文件管理器管理文件的创建、删除和修改
		文件管理器可以给文件命名
		文件管理器管理文件的存储：怎样存储，存在哪里等
		文件管理器负责归档和备份
主流操作系统
	UNIX
		UNIX是多用户，多道程序，可移植的操作系统，它被设计用来方便编程，文本处理，通信
		包含几百个简单的函数
		UNIX结构
			内核
				内核是UNIX的的心脏，它包含操作系统最基本的部分：内存管理、进程管理、设备管理和文件管理
			命令解释器
				 接受和解释用户输入的命令，调用工具等
			工具
				工具是UNIX标准程序，许多系统工具是复杂的应用程序，例如邮件系统，三种文本编辑器
				其他工具是简短函数，如list
			应用
				指不是操作系统中发布的标准部分的程序
	Linux
		具有传统UNIX的所有特性
		内核
			内核负责处理所有属于内核的职责，内存管理等
		系统库
			系统库含有一组被应用程序使用的函数（包括命令解释器），用于与内核交互
		系统工具
			系统工具是使用系统库提供的服务，执行管理任务的各个程序
		网络功能
			支持标准因特网协议
	Windows
		Windows的设计目标是：可扩展性、可移植性、可靠性、兼容性和性能
		可扩展性
			Windows被设计成具有多层的模块化体系结构，意图是允许高层随时间而改变，而不影响底层
		可移植性
			跟UNIX一样
		可靠性
			被设计成可以处理包括防止恶意软件的错误条件
		兼容性
			被设计成可以运行为其他操作系统编写的程序
		性能
			具有快速相应时间
		体系结构
			Windows使用层次体系结构
			HAL硬件抽象层为上层隐藏了硬件的差异
			执行者为整个操作系统提供服务，由6个子系统组成：
			对象管理器、安全引用监控器、虚拟内存管理器、进程管理器、本地过程调用工具和I/O管理
			环境子系统被设计用来允许Windows运行那些为其他操作系统设计的应用程序