许多编程语言已经定义了一些简单的抽象数据类型作为语言的组成部分，例如整数，我们可以对整数加减乘除，而不必直到它是怎么定义的和实现的
对于一个抽象数据类型，用户不关心任务是如何完成的，而是关心能做什么
抽象概念意味着直到一个数据类型能做什么，如何去做是隐藏的
抽象数据类型就是把对该数据类型有意义的操作和它本身封装在一起的数据类型
抽象数据类型（ADT）就是
	数据的定义
	操作的定义
	封装数据和操作
抽象数据类型的模型
	抽象数据类型内部有两个部分，数据结构和操作，操作分为公有操作和私有操作，应用程序只能通过接口访问公有操作
	接口时公有操作和将数据传给这些操作或从这些操作返回的列表，私有操作是抽象数据类型内部用户使用的
	数据结构在抽象数据类型里面，被公有和私有操作使用
	公有操作和接口应该独立于实现，私有操作依赖于抽象数据类型是现实所选择的数据结构
栈
	栈是一种限制线性表，该类列表的添加和删除操作只能在一段实现，称为栈顶，栈是后进先出数据结构（LIFO）
	栈的基本操作有四种，建栈，入栈，出栈和空
	栈的应用可分为四大类，倒转数据，配对数据，数据延迟使用和回溯步骤
		倒转数据
			倒转数据需要一组给定的数据项，将它们依次放入栈中再取出即得到相反顺序的数据项
		配对数据
			我们经常需要在表达式中进行字符的配对，比如检查括号是不是成堆出现
			编译程序使用栈来检查所有的开括号是否与闭括号配对
			定义一个栈
			当还有字符要检查
			{
				把下一个字符赋值给一个char变量
				如果char=左括号
				{
					把char放入栈顶
				}
				如果不等于
				{
					如果char等于右括号
					{
						如果栈为空
						{
							提示没有左括号
						}
						否则
						{
							删除栈顶元素
						}
					}
				}
			}
			如果栈不为空
			{
				提示没有右括号
			}
			这个算法检查有没有左括号，有的话放入栈，继续检查后面的字符，如果不为左括号也不为右括号就进入下一次迭代
			直到找到右括号，检查栈里有没有元素，没有的话就是没左括号，有的话就是有左括号，删除栈顶元素
			没有未检查的字符时跳出循环，判断栈里有没有元素，有的话就是没有右括号
			如果栈为空，那么就是括号都有配对或者没有括号，结束算法
栈的实现
	栈可以通过数组或是链表实现，在数组实现中，我们带有两个域的记录，第一个域用来存储关于数组的信息，把它当作计数域
	第二个域是一个含有栈顶元素索引的整数
	链表的实现是相似的，有一个具有栈名字的额外节点，这个节点也有两个域，一个计数器和一个指向栈顶元素的指针
队列
	队列是一种线性表，该表中的数据只能在尾端插入，并且只能在头部一段删除，队列是先进先出结构(FIFO)
	队列有四个基本操作，建队列，入队，出队和空
		建队列操作建立一个空队列
		入队操作在队列的尾部插入一个数据项
		出队操作删除队列头部的数据项
		空操作检查队列的状态
	队列的应用
		队列是最常用的数据处理结构之一，在所有的操作系统和网络中都有队列的身影。如处理用户需求作业和指令
		队列可以用于组织数据库
		队列可以调节建立数据时快速生成和缓慢处理间的平衡
		比如CPU和打印机相连,CPU把数据放入队列就可以去做其他事情，让打印机慢慢打印，这种队列通常称为假脱机队列
	队列的实现
		队列也可以通过数组和链表来实现
		在数组实现中，有一个带有三个域的记录，第一个域存储关于队列的信息，把它当作计数域
		第二个域是一个队首元素索引的整数，第三个域是队尾元素索引的整数
		链表的实现是相似的，有一个有队列名字的额外节点，这个节点也有三个域，一个计数器，一个指向队首元素的指针
		和一个指向队尾元素的指针
广义线性表
	前两个介绍的都是限制线性表，广义线性表是像插入和删除等操作可以在其中任何地方进行的表，可以在表头，表中间或表尾
	广义线性表的定义是具有如下特性的元素集合
		元素具有相同的类型
		元素顺序排列，这意味着有第一个元素和最后一个元素
		除第一个元素外每个元素都有唯一的前驱，除最后一个元素外每个元素都有唯一的后继
		每个元素是一个带有关键字域的记录
		元素按关键字值排序
	广义线性表有6种常用操作，建表，插入，删除，检索，遍历和空
		建表操作建立一个空表
		假定广义线性表中的数据是已排序的，插入操作就必须在保持元素顺序的情况下进行，这就需要查找
		查找完毕把数据插在能保持顺序的地方
		从广义表中删除数据也需要查找表，以找到要删除元素在表中的位置
		检索的意思就是单个元素的存取，像插入和删除操作一样，首先查找，找到后再进行操作
		前面的操作之操作表中的一个元素，是随机存取，遍历涉及表的顺序存取，表中的元素逐一被处理
		空操作检查表的状态，表为空返回true，表非空返回false
	广义线性表的应用
		广义线性表可以应用于元素被随机存取或顺序存取的情况，例如在学校里线性表可以用来存储每个学期入学的学生信息
	广义线性表的实现
		广义线性表同样可以通过数组或链表来实现
		在数组实现中，用一个带有两个域的记录，第一个域用来存储关于数组的信息，把它当作计数域
		第二个域是一个含有表中首元素索引的整数
		链表的实现是相似的，用一个具有表名字的额外节点，这个节点也有两个域，一个计数器和一个指向首元素的指针
树
	数包含一组有限的元素，称为节点或顶点，同时包括一组有限的有向线段，用来连接节点，称为弧
	如果树是非空的，其中有一个节点没有进入的弧该节点称为根，树中的其他节点都可以沿着从根开始的唯一路径到达
	该路径是指一系列相邻链接的节点序列，树的结构通常被画成上下颠倒，根在顶部 
	我们可以把树中的顶点分成三类，根，叶子和内部节点
		根进入弧0个，外出弧0或更多
		叶子进入弧1个，外出弧0个
		内部节点进入弧一个，外出弧1或更多
	从一节点可以直接到达的节点称为子节点，从其出发子节点可以直接到达的节点称为父节点，具有相同父节点的节点称为兄弟节点
	节点的子孙是指从该节点出发可以到达的所有节点，而从其出发所有的子孙都可以到达的节点称为祖先
	树中每个节点都可能有子树
	树在计算机科学中有许多应用，如索引文件等，但这里只介绍二叉树
二叉树
	二叉树任意节点只能有0，1或2棵子树，这些子树被描述为左子树和右子树
	二叉树的递归定义
		我们也能递归定义一个结构或一个抽象数据结构，基于这个定义，二叉树可以有一个根，而每棵子树也可以有一个根
	二叉树是一个空树或由一个根节点和两棵子树构成，而每棵子树也是二叉树
	二叉树中6种最常用的操作是建树，插入，删除，检索，空和遍历
	二叉树的遍历
		二叉树遍历要求按照预定的顺序处理每一个节点而且仅处理一次，两种常用的遍历次序是深度优先和广度优先
		深度优先遍历
			给定一棵由根、左子树、右子树构成的二叉树，我们可以定义六种不同的深度优先遍历次序，有三种定义了名称
			前序遍历中，根首先被访问，接着是左子树，最后是右子树
			中序遍历中，先处理左子树，然后是根，最后是右子树
			后序遍历中，根在左右子树都被处理完后才处理
		广度优先遍历
			广度优先遍历中，先处理节点的所有子节点，然后再进行下一层所有的子节点
	二叉树的应用
		二叉树在计算机科学中也有许多应用，这里只介绍两种，赫夫曼编码和表达式树
		赫夫曼编码是一种压缩计数，使用二叉树生成一个符号串的可变长度的二进制编码，这本书后面将详细介绍
		表达式树
			一个算术表达式可以用三种格式来表示，中缀 A + B，后缀 A B +，前缀 + A B
			在编程语言中通常使用中缀表示，但编译程序在计算表达式之前需要把他们变为后缀表示
			进行转换的一种方法就是建立表达式树，在表达式树中，根和内部节点是操作符，叶子是操作数
			这样用三种深度优先遍历方式就可以转换为前缀后缀和中缀表示的表达式
		二叉树可以使用数组或链表实现，对于删除和插入操作，链表实现的效率更高，所以要更为流行
		二叉搜索树（BST）
			二叉搜索树是一种具有额外特性的二叉树，每个节点的关键字值大于左子树中所有节点的关键字值
			而小于右子树中所有结点的关键字值，所有子树都是二叉搜索树且整棵树也是二叉搜索树，才是二叉搜索树
			对二叉搜索树使用中序遍历就可以创造一个升序的列表
			二叉搜索树还能使用折半查找，如果目标值小于根节点，就去查找左子树，大于就去查找右子树
			二叉搜索树的抽象数据类型与具有相同操作的广义线性表类似，如今BST比广义线性表要更常见
			因为BST查找效率比广义线性表高，前者可以折半查找，后者只能顺序查找
			二叉搜索树同样可以使用数组或链表实现，链表更常见效率更高
			线性实现使用带有两个指针的节点，左指针和右指针，左指针指向左子树，右指针指向右子树
			如果左子树为空，左指针也为空，右指针同理
			跟广义线性表一样，BST的链表实现也是使用一个额外的节点
			该节点数据部分含有关于树的信息，如节点的数目等，指针部分指向树的根
图
	图是由一组节点（称为顶点）和一组顶点间的连线（称为边或弧）构成的一种抽象数据类型
	图的节点之间可以随意连接
	图可能是有向的或无向的，在有向图中连接两个顶点的边都有从一个顶点到另一个顶点的方向
	在无向图中，边是没有方向的
	图中的顶点可以代表对象或概念，关系是单向的图就有向，关系是双向的图就无向