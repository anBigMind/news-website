信息是一种有价值的资产，需要被保护，为了安全，信息需要避开未授权的使用（机密性），保护信息不受到未授权的篡改（完整性）
并且对于得到授权的实体来说是可用的（可用性）
安全目标
	首先讨论三个安全目标：机密性、完整性和可用性
	机密性
		机密性不仅仅适用于信息的存储，在信息的传输中它也得到了应用，当我们将信息发送至其他计算机时，也应该对信息进行隐藏
	完整性
		信息需要不停的变化，完整性就是变化只应该由授权的实体通过授权的机制来完成，完整性冲突不一定是由恶意行为造成的
		它也可能是系统中断造成的对信息的一些不希望的改动
	可用性
		一个组织创建和存储的信息对授权实体来收应该是可用的，如果信息是不可用的，那他就是无用的
攻击
	这里我们按照目标将攻击分为三类
		对机密性的威胁：嗅探，流量分析
		对完整性的威胁：篡改，假冒，重放，抵赖
		对可用性的威胁：拒绝服务
	威胁机密性的攻击
		嗅探
			嗅探是指对数据的非授权访问或侦听，一个通过因特网传输的文件可能被侦听到，为了防止侦听
			可以使用下面要讨论的加密技术，使数据对侦听者来说难以理解
		流量分析
			虽然通过加密技术我们可以使得数据对侦听者来说难以理解，但他们仍然可以通过流量监控获取到其它类型的信息
			使得他们可以猜测数据的内容或其代表的意义
	威胁完整性的攻击
		篡改
			侦听或访问信息后，攻击者篡改信息，使得信息有利于他们，例如，一个客户可能向银行发送一消息来完成交易
			攻击者就可以篡改这条消息来获利
		假冒
			当攻击者冒充其他人时，假冒或哄骗就发生了，一个攻击者可能会盗窃银行卡和银行客户的PIN来假装是这个客户
			攻击者又可以假装银行来获取到银行卡和银行客户的PIN
		重放
			重放是另一种类型的攻击，攻击者得到用户发送的信息的副本，并再次发送它，比如一个人给银行发送了一条给
			攻击者付款的请求，攻击者复制这个消息并再次发送，尝试得到另一次付款
		抵赖
			抵赖是一种不同于其它类型的攻击，因为它是由通信双方来进行的，消息的发送者可以抵赖他发送过消息
			消息的接收者也可以抵赖他接收到了信息，比如网购退款，收款者抵赖自己收到了付款，并要求再付
	威胁可用性的攻击
		我们在这里只讨论一种威胁可用性的攻击，拒绝服务（DoS）
		DoS攻击是很常见的，他可能减慢或完全中断系统的服务，攻击者能用几种策略取得这样的效果
		他们可能通过发送大量的虚假请求使得系统变得非常繁忙而崩溃，也通过侦听并删除服务器对客户端的响应
		使客户端相信服务器未响应，也可以侦听客户端的请求，使客户端多次发送请求导致系统变得非常忙碌
服务和技术
	为了达到安全目标，ITU-T定义了一些安全服务的标准，实际完成安全目标需要一些技术手段，现今流行两种技术
	一种是非常普通的密码术，一种是比较特殊的隐写术
	密码术
		密码术过去只是指用密钥进行加密解密，如今被定义成三种不同的机制，对称密钥密码，非对称密钥密码和散列
	隐写术
		隐写术通过在消息上面覆盖其他内容而隐藏信息
机密性
	对称密钥密码术
		它使用了同一个密钥进行加密和解密，并且这个密钥可以用来进行双向通信，这就是为什么它被称为对称的
		在对称密钥中，加密算法用密钥把明文加密成密文，然后发送，接收方用相同的密钥用解密算法解密密文还原明文
		密文通过公开通道传输，而密钥通过某种安全方法交换，对称密钥密码又可以分为两大类，传统的和现代的
		传统的密码很简单，面向字符的密码对现在的标准来说是不安全的，现代密码是更安全的更复杂的面向位的密码
		传统对称密钥密码
			传统密码属于过去，然而它是现代密码的构成要素，传统密码又可以分为替换密码和移位密码
			替换密码用一个符号替换另一个符号，如果在明文中的符号就是字母表中的字符，我们用另一个字符来代替
			比如用D代表A，用7代表3，替换密码又可以分为单字母密码和多字母密码
				单字母密码中，明文中相同的字符用相同的字符替换，与该字符在明文中的位置无关
				最简单的单字母密码就是加法密码，每个字符都进行一个赋值，加密就是将密钥加上明文字符
				解密就是密文字符减去密钥，历史上，加法密码也被称为有移位密码，尤利乌斯·凯撒就是
				用密钥为3的加法密码进行通信的，所以加法密码也被称为凯撒密码
				多字母密码中，字符每出现一次都用不同的替换码，明文中字符和密文中字符的关系是一对多
				a可以在开头加密成B，也可以在中间加密成N，多字母密码卡哇伊起到隐藏原有语言字母频率的作用
				即使通过单字母频率统计都无法破解密文，为了创建一个多字母密码，我们对每一个密文字符的
				确定都与明文在原来文本中的位置有关，要做到这一点，我们需要一个密钥流，其中每一个子密钥
				都用来加密明文中对应位置的字符
			移位密码是改变符号的位置，换言之，移位密码就是符号重新排序，用来加密的和解密的密钥是相同的
			但是算法使用密钥的顺序是互逆的
			文献中又将对称密码分为两大组，流密码和分组密码
				流密码中加密和解密都是一次只对一个符号进行，其中有一个明文流，一个密文流，一个密钥流
				分组密码中，一组大小为m的明文符号被加密在一起，创造一组同样大小的密文
				一个分组密码中，整个分组是有单独的一个密钥进行加密，密文的分组取决于整个明文分组
				在实际操作中，我们组合使用它们，每个明文分组是分组加密的，同时用密钥流来对每个分组再次加密
				从整体来看，这种密码是一个以分组为单位进行加密的流密码，而每个分组又是被单独加密的分组密码
				这些密钥是在加密前或加密中产生的
		现代对称密钥密码
			传统对称密钥密码都是面向字符的密码，随着计算机的进步，我们需要面向位的密码来加密数字，图标，音频和视频
			这种情况更方便的方法是把这些数据转换成比特流再对流进行加密，当文本在比特级进行处理时，每个字符会被
			转换为8或16位，这就使得字符位数的数量变成了原来的8或16倍大，将更多的字符混合可以提高安全性
			现代密码既可以是分组密码也可以是流密码
			现代分组密码对大小为n位的明文分组进行加密或对同样大小的密文分组解密，，解密算法必须是加密算法的逆运算
			且两个操作使用相同的密钥，当消息长度小于n位时消息后会加补丁使消息长度达到n位，如果超过n位
			就会被分为几个长度为n的分组，如果必要最后一个分组也会添加补丁
			现代流密码流密码比分组密码更快，它的硬件实现也更简单一点，当我们需要对二进制流加密并匀速传输时
			流密码是更好的选择，而且对于传输中发生的损毁也有更好的免疫能力
			最简单也最安全的同步流密码是吉尔伯特·佛纳姆发明并取得专利的一次一密乱码，一次一密乱码每次加密时
			使用随机选择的密钥流，加密和解密都是用单一的异或操作，基于异或操作的性质，加密和解密的算法互为逆运算
			这个密码中的异或操作一次只用一比特，并且还需要一个安全通道来将密钥流序列发给接收者
			一次一密乱码是一个理想化的密码，它很完美，不仅敌手无法猜测密钥或者明文与密码的统计
			明文和密文之间也没有任何联系，如果要暴力破解，当明文长度为n位时，就需要尝试2^n次
			但是如何安全的传输密钥是个问题，所以很难实现这个密码，也有一些可行但安全性较低的版本
			一个较常见的选择是反馈移位寄存器（FSR），这里不讨论
	非对称密钥密码术
		对称密钥密码和非对称密钥密码可以取长补短，相互补充，从概念上来说，这两种系统的差别是如何保守秘密的
		对称密钥密码术中，密码必须在双方之间共享，在非对称密钥密码术中，密码是个人独有的
		比如在有100人的一个社区中，对称密钥密码术需要500个密钥，而非对称密钥密码术只需要100个
		安全性在加密以外还有其他方面需要非对称密钥密码术，包括身份验证和数字签名，无论一个应用是否基于个人秘密
		我们都需要使用非对称密钥密码术。
		非对称密钥密码术基于数学函数在数字上的应用，明文和密文被看作符号的组合，加密和解密是对这些符号的排列或替换
		在非对称密钥密码术中，明文和密文都是数字，加密和解密的过程是对数字应用数学函数并创造其他数字的过程
		非对称密钥密码术中使用两个分开的密钥：公钥和私钥，用公钥加密的数据只能被对应的私钥解密
		密钥，公钥和私钥三者完全不同，不可混为一谈，非对称密钥密码有时也称为公钥密码
		主要思想
			它强调了密码系统的非对称本性，提供安全的重担全部落在了接收者的肩上，接收者需要创建两个密钥，公钥和私钥
			他有义务把公钥分发给团体，这可以通过公钥分发通道来进行，这个通道不需要保证安全，但它必须提供
			身份和完整性验证，其他人不能把其他的公钥假装成另外一个人的公钥发布，其次通信双方无法使用一组密钥
			每个需要接受文件的人都需要创建一组公钥和私钥，创建一组密钥并发布公钥之后就可以接受来自任何人的加密文件
			非对称密钥密码术通常用来加密或解密小段消息，比如对称密钥密码术的密钥，也就是说它通常起到的是辅助作用
			这两个系统在当今的加密中都是非常重要的，通过数学函数进行加密和解密的非对称密钥密码术比对称密钥密码慢很多
			另一方面，身份验证，数字签名和秘密密钥交换仍然需要用到非对称密钥密码术
			这就意味着我们需要配合使用这两种才能使用到当今安全性的每一个领域
		RSA密码系统
			虽然有几种非对称密钥密码系统，但最常用的公钥算法之一时RSA密码系统，RSA使用两个指数e和d，
			其中e是公钥，d是私钥，随便选俩数p和q，计算p*q得到n，然后再计算（p-1）*（q-1）得到（n）
			再选择两个数e和d，使e * d %（n） = 1，然后把e和n公开发布，发送方就可以用明文^e % n来得到密文
			接收方就可以用密文^d % n来得到明文，RSA加密很长的信息速度会很慢，因为所需要的数都太大了
			因此它适用于加密短信息，RSA特定用于数字签名以及不需要使用对称密钥加密的较短信息，还用于身份验证
其他安全服务
	到目前为止我们研究的密码系统提供了机密性，但我们还需要完整性，消息和实体验证，不可抵赖性和密钥管理
	消息完整性
		有些场合我们不需要保密，却需要保证消息的完整性
		消息和消息摘要
			保证纸质文档完整性的一种方法是通过指纹，文档和指纹在计算机中对应的东西就是消息和摘要对
			为了保证消息完整性，消息通过一个称为密码散列函数的算法，简历信息的压缩影响
			接收者通过安全通道接受摘要，将收到的消息再次运行密码散列函数，看得到的摘要和收到的摘要是否相同
			如果相同则证明此文件没有被更改过，这其中最重要的是保护消息摘要安全免受篡改
		散列函数
			散列函数及那个任意长度的消息加密成固定长度的信息摘要，所有的散列函数加密都要从长度不一的消息中
			创造出长度固定的消息摘要。罗恩·李维斯设计的几个散列算法被称为MD2,MD4,MD5，MD是消息摘要的意思
			它可以将消息分成长度为512位的分组并创造大小为128位的摘要，然而事实证明128位太小不够安全
			为此，安全散列算法（SHA）诞生了，它是由国家标准与技术研究所（NIST）研制的一个标准，经过了几个版本
	消息验证
		消息验证过程中我们需要双方都有一个共享的密钥，用密钥和散列函数创造一个消息验证码（MAC），然后把消息
		和MAC从不安全通道发送给接收者，然后接收者用密钥和散列函数再次生成MAC和接收到的比较，如果相同则没有被篡改
		MAC通过散列函数和密钥的组合来保证消息的完整性和消息验证
		HMAC
			NIST发布了新一代MAC标准，通常称为HMAC（散列消息验证码），它的实现更复杂，这里不讨论
	数字签名
		保证消息完整性和消息验证的另一种方法是数字签名，MAC通过密钥来保护消息摘要，数字签名则使用一组公私钥
		对比普通签名（纸质文件）和数字签名的不同
			包含：普通签名是包含在文档里的，但是当对文档进行数字签名时，我们把签名作为一个单独的文档来发送
			验证手段：对于普通签名，当接收者接收到文件时，把上面的签名和其他这个人的签名比对，如果一样
			就证明文档是可信的，对于数字签名，接收者收到消息和签名，签名的副本就不在保存
			接收者应用验证技术来组合消息和签名，来验证发送者的身份
			关系：对于普通签名来说，一个人使用相同的签名签署许多文档，但是对于数字签名来说，签名和消息之间
			是一对一的关系
			复制性：两种签名的另一点不同是称为复制性的特质，普通签名循序签署文档的副本与文件中的原始件有点不同
			对于数字签名，就没有这样的不同，除非在文档上有时间因子，比如时间戳
		过程
			发送者使用签名算法去签署消息，消息和签名被发送给接收者，接收者收到消息和签名，对收到的内容应用验证算法
			如果结果是真，消息被接受，否则消息被拒绝
			对于数字签名，签署者用私钥去签署文档，验证者使用签署者的公钥验证文档
			不能用一个对称的密钥去签署文档，因为这样拥有密钥的人都可以伪造签名
			数字签名需要公钥系统，密码系统使用接收者的公钥和私钥，数字签名使用发送者的公钥和私钥
		签署摘要
			当处理较长信息时，非对称密钥密码系统的效率低效，但是在数字签名系统中我们又不得不使用非对称密钥模式
			解决这个问题的方法是签署信息的摘要，接收者同样是验证信息的摘要，和签署整个文件效果是相同的
		服务
			我们在本章开头讨论了几个安全目标，包括机密性，完整性和不可抵赖性，目前还剩下不可抵赖性
			一个解决方案就是可信的第三方，人们可以在他们之间建立可信中心，在这种模式下，发送方从他的信息中创造标识
			然后发送他的消息，他的标识，和接收方的标识和签名到可信中心，中心检查发送方的公钥是合法的并验证之后
			将带有发送者标识，接收者标识和时间戳的消息副本保存在档案中，中心使用它的私钥创建另一个签名，
			然后把消息，新的签名，发送者的标识和接收者的标识发送给接收者，接收者使用可信中心的公钥验证消息
			数字签名不提供机密通信，如果机密性是需要的，那么消息和签名就要加密
	实体验证
		实体验证来使一方证明另一方标识，一个实体可以是一个人，一个过程，一个客户端或一个服务器
		身份需要证明的实体称为要求者，试图证明要求者身份的一方称为证明者
		实体验证与消息验证
			消息验证可能不会发生在实时系统中，而实体验证是会的，消息验证简单的验证一则消息，这个过程需要对每则新消息重复
			实体验证可在整个会话期间验证要求者
		验证分类
			在实体验证中，要求者必须向证明者表示自己，这可以使用下面三种证据中的其中一种：所知道的、所拥有的和所固有的
			所知道的是一种只有要求者知道的秘密，证明者可以通过它来检查要求者，比如密码、密钥和私钥
			所拥有的能证明要求者的身份，比如护照，身份证，驾照和信用卡等
			所固有的是要求者内在固有的特性，比如签名，指纹，声音，面部特征
			这部分我们只讨论所知道的，其他两种通常在真人身上用
		密码
			最简单且最古老的实体身份验证的方法是基于密码的身份验证，密码是要求者知道的一些东西
			每个用户都有一个用户标识，这是公开的，还有一个密码，这是私有的，然而密码在攻击面前很脆弱
		质询相应
			在密码验证中，要求者通过展示密码来证明他们的身份，但是密码一旦被发送就有可能被截获破解
			在质询-相应身份验证中，要求者证明他们知道秘密，而不需要把秘密发送给证明者
			质询是一个随时间变化的值，如随机数或一个时间戳，它由证明者发送给要求者，要求者对质询应用一个函数
			把结果（响应）发送给证明者，相应表明要求者知道秘密
			质询-相应可以通过对称密钥密码，非对称密钥密码和数字签名来达到
	密钥管理
		对称密钥密码需要双方共享一个密钥，这意味着如果有N个人需要互相通信，每个人都要有N个密钥，一共需要N(N-1)个密钥
		并且还需要考虑到分发的问题，如何安全的分发密钥，一个实用的解决办法是使用可信第三方，密钥分发中心（KDC）
		为了减少密钥的数量，每个人和KDC建立一个共享的密钥，发送方向KDC发送一个请求，需要一个和接收方的会话
		KDC告诉接收方发送方的请求，如果接收方同意，一个会话密钥就在二者间建立了
		当使用同一个密钥分发中心的人增多时 ，系统会变得难以管理，为解决这个问题，我们可以拥有多个密钥分发中心
		我们将世界划分成区域，本地的联系用本地KDC，本国的联系用本国KDC，异国的联系用国际KDC
		KDC为每个成员建立一个密钥，这个密钥只能在成员和KDC之间使用，当两个人需要通信，KDC会建立一个临时密钥
		当通信终止后，这个临时密钥便不再有效
	公钥分发
		在非对称密钥密码术中，人们不需要对称的共享密钥，而只需要知道接收者的公钥，每个人有权访问每个人的公钥
		公钥的分发最朴素的方法就是公开声明，但是这种方法有可能被伪造公钥，导致发送的文件送到了伪造者手中
		最常用的分发公钥的方法就是建立公钥认证，用户可以去认证机构（CA）来分发公钥并确保其他人无法伪造
		CA是一个把公钥和实体捆绑认证的机构，CA本身有一把众所周知的公钥，这把公钥不能被伪造
		通过CA认证后，CA用它的私钥签署证书，任何需要其公钥的人都可以下载签署的证书，并用中心的公钥来抽取出用户的公钥
		虽然CA的使用解决了公钥骗局的问题，但它也有副作用，每个证书的格式都不一样，这就是的程序无法自动处理这些证书
		ITU设计了X.509，他是一个结构化描述证书的方式，他使用ASN.1协议
防火墙
	前面这些安全测试都无法阻止攻击者对系统发送有害信息，我们需要防火墙来控制对系统的访问，防火墙是一个安装在组织的内部网络
	和因特网之间的设备，通常是一个路由器或计算机，他是为了推进一些数据包而过滤其他数据包而设计的
	防火墙通常分为包过滤防火墙和代理防火墙
	包过滤防火墙
		防火墙可以被用作数据包过滤器，它可以基于源和目标IP，源和目标端口以及协议的种类来推进或阻拦数据包
	代理防火墙
		包过滤防火墙是基于网络层的有效信息和传输层头部建立的，然而有时我们也需要基于数据包携带的消息进行判断
		解决措施就是应用代理防火墙，安装代理计算机，当用户客户进程发送消息时，用代理服务器打开数据包并查看数据是否合法
		如果是，那么服务器运行客户端进程并把消息发给真正的服务器，否则这个消息将被丢弃并且向外部用户发送错误消息