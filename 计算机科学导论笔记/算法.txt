算法是一种逐步解决问题或完成任务的方法
三种结构
	程序必定是由顺序，判断，循环这三种类型组成
		顺序就是指令序列
		判断
			有些问题只用简单的指令序列无法解决，有时需要检测一个条件是否满足
		循环
			在有些问题中，相同的指令序列需要重复
算法的表示
	UML
	伪代码
算法是一组明确步骤的有序集合，它产生结果并在有限时间内终止
	算法的每一步都必须有清楚明白地定义
	算法必须产生结果
	算法必须能够终止
基本算法
	选择排序
		n个数的列表需要n-1轮排序
		将墙放在列表最左端，外层循环检测还有没有数未排序
		内层循环找到未排序列表中的最小元素
		将最小的元素和为排序列表的第一个数交换
		将墙向右移动一个数
	冒泡排序
		n个数的列表需要n-1轮排序
		将墙放在列表最左端，外层循环检测还有没有数未排序
		内层循环从最右边开始比较相邻两个数，如果右边的比左边小，交换位置，如果相等或左边小，则不交换
		每比较一次向前移一位，继续比较（比如一共五个数，比较4，5，再比较3，4，再2，3，以此类推）
		当全部判断完会把最小的元素移到未判断列表的最左端，墙右移一位
		如果一轮判断中没有元素被交换，代表已经排序完，可以终止排序，比等循环完所有的数省循环次数
	插入排序
		n个数的列表需要n-1轮排序
		将墙放在列表最左端，外层循环检测未排序列表还有没有数
		内层循环把未排序列表最左端的数和已排序列表中的比较，插入合适的位置
		从左往右比较，遇到更小的数往后移继续比较，遇到更大的插它前面
		如果比较完没有找到更小的，就插在最后
	顺序查找
		可以用于无序和有序列表
		从列表开始处进行查找，当找到目标元素后停止返回位置
		到达列表末尾找不到元素停止查找，返回找不到元素
	折半查找
		只能用于有序列表
		定义三个变量，first，mid，last
		first为列表第一位，last为列表最后一位，mid为（first+last）/2，取整
		比较目标数和位置mid的数，如果目标数更大，则忽略mid以前的数，把first放到mid后面一位
		如果目标数更小，忽略mid后面的数，把last移动到mid的前面一位
		重新比较mid位置的数和目标数，直到找到目标
		找不到目标时最后first的值会大于last的值，所以当first>last，程序停止返回找不到目标
子算法
	将算法分成几个单元，比如在选择算法中，查找未排序列表的最小值这项任务就可以单独写作一个子算法
	这样写算法更方便理解和调用
递归
	递归调用算法（函数）自身，比如阶乘的递归解法
	digui(int n){
		digui（n-1）*n
		n为0时停止
	}
	digui（n-1）执行时又调用了这一段代码，这一段代码中又包含了它本身，所以就会一直执行到符合停止条件